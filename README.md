# Evolutionary-Prisoner-Dilemma
For the course Introduction to Adaptive Systems, I created an integration of the evolutionary prisoner's dilemma, together with my partner Arian.

## WHAT IS IT?

This model demonstrates a so-called evolutionary prisoner's dilemma. In the evolutionary prisoner's dilemma, each patch plays the prisoner's dilemma against its neighbours, after which it adopts the strategy that beats it the hardest, i.e. the strategy that gets the highest payoff. The prisoner's dilemma is as follows: Two suspects are arrested by the police. The police have enough evidence to convict the two suspects. They therefore separate the two, visit each of them and offer them the same deal: "If you confess and your accomplice remains silent, he will go to jail for 10 years and you can go free. If you both remain silent, only minor charges can be brought against you both and you will each get 6 months. Any defendant can reason as follows: "Whether my partner confesses or not. If he confesses and I remain silent, I will get 10 years and if I confess, I will get 5 years. So if my partner confesses, it is better that I confess and only get 5 years than that I get 10 years in prison. If he does not confess, I get off scot-free, but if I remain silent, I get 6 months. So if he didn't confess, it is best that I confess so that I go free. Whether my partner confesses or not, it is best that I confess. "In a non-iterated prisoner's dilemma, the two partners will never have to work together again. Both partners think in the above way and decide to confess. As a result, they both get five years in prison. If neither had confessed, they would have received only 6 months each. In an Iterated Prisoner's Dilemma, as in our model, the prisoner's dilemma is repeated several times. This changes a lot. How do you come out best after, say, 100 rounds? Several strategies have been devised for this. In this model we show which strategies are best for this, by colouring patches to the dominant strategies.

## HOW IT WORKS

First, a scoring table is computed that calculates the score of playing the IPD per strategy against any other strategy. This table is 9x9 in size (9 strategies). Next, the patches in the field are assigned a random strategy depending on the starting variables per strategy. When you then run the simulation, the scores are taken from the score table and the correct payoff is calculated for each patch. The highest payoff near the playing patch is chosen as the winning patch and takes over the colour of the playing patch. This happens symmetrically over the whole field. At some point you see that certain strategies become dominant. The variabale noise indicates disturbance. With noise, the simulation will in certain cases not play strictly against its neighbours, but choose a random action.

## HOW TO USE IT

Click on SETUP to calculate the score table and initialise the run. Then press GO to run the simulation (STEP is 1 tick). With the help of the start variables, you can influence the layout of the grid. If you click on RECALC, you can recalculate the score table without restarting the whole simulation. This is useful, for example, if you change the variables rounds and restarts. These variables influence the calculation of the score table. How often you calculate the score table affects the average score given by two strategies, if the variable noise has a value greater than 0. Clicking RESET reinitialises the run without recalculating the score table. If you press cooperation (the button), it is visualised which patches currently have action 0, i.e. cooperate. If you press payoff, it is visualised which patches have the highest payoff. The whiter the patches, the higher the average payoff. In the plot at the top right, you can see what the proportions are between the strategies. In the output below that, you can see how many patches there are per strategy. This is briefly how to use and read the simulation.

## THINGS TO TRY

As an extra function, you can also give the slider strategies-to-pit a value. This value n changes n number of starting variables to 1/n. Nice to try! Make sure that the switch pit? is set to ON.
